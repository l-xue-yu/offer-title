package main

/*
题目：请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
*/

/*
知识点：
1.二进制的位运算，与，或，异或，左移，右移
1.1左移，高位舍弃，低维补0
1.2右移，如果数字是一个无符号数值，则用0填补最左边的n位。如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。
也就是说如果数字原先是一个正数，则右移之后在最左边补n个0；如果数字原先是负数，则右移之后在最左边补n个1。
简化下：右移，无符号数值，uint类型，直接用0填补最左边，如果是int类型，是正整数就补0，负数就补1。
1.3异或，相同则为0，不相同则为1。
1.4与，都为1则为1，否则为0。
1.5或，有一个为1，则为1，否则为0。
1.6规律1，把一个整数减去1，都是把它的二进制标识最右边的1变成0。比如12的二进制1100,12-1=11,11的二进制1011,12&11=1000=8
*/

func main() {
	result := numberOf1Last(-9)
	println("1的个数：", result)
}

/*
解法1，正整数
思路：
依次对num的各个位上的数字和1进行&操作，
比如1011&1,就是1011&0001，结果是0001就是1，那么count++,并右移。
101&0001，也是1，count++,并右移。
1&1，还是1，count++
进行右移操作
*/
func unnumberOf1(num uint32) int {

	count := 0

	//只适应正整数
	for num != 0 {
		if num&1 == 1 {
			count++
		}
		num = num >> 1
	}
	return count
}

/*
解法2，正整数，负整数，使用左移
思路：
1.利用1的左移规律1<<1=0010=2,2<<1=0100=4,4<<1=1000=8,依次类推，和1的每次左移，可以判断num该位置上是不是1
2.可以避免，负数情况下的右移的死循环
*/
func numberOf1(num int) uint32 {
	var count uint32
	flag := 1

	for flag != 0 {
		if flag&num >= 1 {
			count++
		}
		flag = flag << 1
	}
	return count
}

/*
解法3,
使用技巧，把一个整数减去1，都是把最右边的1变成0
如12==1100，12-1=11==1011，,12&11=1000=8，
8-1=7=0111,1000&0111=0,这时num已经变成0，该整数所有的1已经被减去（计数）
*/

func numberOf1Last(num int) uint32 {
	var count uint32
	if num < 0 {
		num = num * -1
	}
	for num > 0 {
		count += 1
		num = (num - 1) & num
	}
	return count
}
